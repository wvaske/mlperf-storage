"""
Data models for lockfile operations.

This module contains all the data classes used for representing locked packages,
validation results, and lockfile metadata. These classes are used throughout
the lockfile system for parsing, validation, and reporting.
"""

import re
from dataclasses import dataclass, field
from typing import Dict, Optional


@dataclass
class LockedPackage:
    """
    A package entry from a lockfile with pinned version.

    Represents a single package requirement as specified in a lockfile,
    including version constraints, hashes for verification, environment
    markers, and support for editable/VCS installations.

    Attributes:
        name: Distribution name (e.g., "requests")
        version: Pinned version (e.g., "2.31.0")
        hashes: List of SHA256 hashes for package verification
        markers: Environment markers (e.g., "; python_version >= '3.10'")
        is_editable: Whether package is installed in editable mode
        source_url: For VCS/URL dependencies (e.g., git+https://...)
    """
    name: str
    version: str
    hashes: list[str] = field(default_factory=list)
    markers: str = ""
    is_editable: bool = False
    source_url: str = ""


@dataclass
class ValidationResult:
    """
    Result of validating a single package against lockfile.

    Captures the outcome of comparing an installed package version
    against the expected version from the lockfile.

    Attributes:
        package: Package name
        expected: Version from lockfile
        actual: Installed version (None if not installed)
        valid: Whether versions match
        message: Human-readable status message
    """
    package: str
    expected: str
    actual: Optional[str]
    valid: bool
    message: str


@dataclass
class LockfileMetadata:
    """
    Metadata about a lockfile.

    Contains information about the lockfile itself (path, generation details,
    target platform) and the collection of locked packages.

    Attributes:
        path: Path to lockfile
        generated_by: Tool that generated it (e.g., "uv pip compile")
        generation_date: ISO date string
        python_version: Python version constraint
        platform: Platform (e.g., "linux", "universal")
        packages: Dictionary mapping package names to LockedPackage instances
    """
    path: str
    generated_by: str = ""
    generation_date: str = ""
    python_version: str = ""
    platform: str = ""
    packages: Dict[str, LockedPackage] = field(default_factory=dict)


def parse_lockfile(lockfile_path: str) -> LockfileMetadata:
    """
    Parse a pip-compile/uv generated requirements.txt lockfile.

    Handles:
    - Package==version lines
    - --hash=sha256:xxx lines
    - # comments (including via: lines for source tracking)
    - Environment markers (package==1.0; python_version >= '3.10')
    - VCS/URL dependencies (package @ git+https://...)

    Args:
        lockfile_path: Path to the requirements.txt lockfile

    Returns:
        LockfileMetadata with parsed packages

    Raises:
        FileNotFoundError: If lockfile doesn't exist
        ValueError: If lockfile format is invalid

    Examples:
        >>> meta = parse_lockfile('requirements.txt')
        >>> print(list(meta.packages.keys()))
        ['requests', 'pyyaml', 'numpy']
        >>> print(meta.packages['requests'].version)
        '2.31.0'
    """
    try:
        with open(lockfile_path, 'r') as f:
            content = f.read()
    except FileNotFoundError:
        raise FileNotFoundError(f"Lockfile not found: {lockfile_path}")

    metadata = LockfileMetadata(path=lockfile_path)

    # Regex patterns
    # Match: package==version or package>=version (with optional markers)
    package_pattern = re.compile(r'^([a-zA-Z0-9_-]+)(==|>=)([^\s;]+)(.*)$')
    # Match: package @ url
    url_pattern = re.compile(r'^([a-zA-Z0-9_-]+)\s*@\s*(.+)$')
    # Match: --hash=sha256:xxx
    hash_pattern = re.compile(r'--hash=sha256:([a-f0-9]+)')
    # Match: -e package or --editable package
    editable_pattern = re.compile(r'^(-e|--editable)\s+(.+)$')

    lines = content.split('\n')
    current_package = None

    for line_num, line in enumerate(lines, 1):
        # Strip whitespace but preserve the original line for hash continuation
        stripped = line.strip()

        # Skip empty lines
        if not stripped:
            continue

        # Handle comments - extract metadata
        if stripped.startswith('#'):
            # Extract generation metadata from comments
            if 'generated by' in stripped.lower():
                # e.g., "# This file was autogenerated by uv via the following command:"
                parts = stripped.lower().split('generated by')
                if len(parts) > 1:
                    tool = parts[1].strip().split()[0] if parts[1].strip() else ""
                    metadata.generated_by = tool
            elif 'python' in stripped.lower() and 'version' in stripped.lower():
                # Extract python version if mentioned
                match = re.search(r'python[_\s]*version[:\s]*([\d.]+)', stripped.lower())
                if match:
                    metadata.python_version = match.group(1)
            continue

        # Handle hash lines (continuation of previous package)
        if stripped.startswith('--hash=') and current_package:
            hash_match = hash_pattern.search(stripped)
            if hash_match:
                current_package.hashes.append(hash_match.group(1))
            continue

        # Handle backslash continuation (just skip, hashes on next line)
        if stripped == '\\':
            continue

        # Handle editable packages
        editable_match = editable_pattern.match(stripped)
        if editable_match:
            source = editable_match.group(2)
            # Try to extract package name from source
            name_match = re.search(r'/([^/]+?)(?:\.git)?$', source)
            if name_match:
                pkg_name = name_match.group(1).lower().replace('_', '-')
                current_package = LockedPackage(
                    name=pkg_name,
                    version="editable",
                    is_editable=True,
                    source_url=source
                )
                metadata.packages[pkg_name] = current_package
            continue

        # Handle VCS/URL dependencies (package @ url)
        url_match = url_pattern.match(stripped)
        if url_match:
            pkg_name = url_match.group(1).lower()
            source_url = url_match.group(2).strip()
            current_package = LockedPackage(
                name=pkg_name,
                version="url",
                source_url=source_url
            )
            metadata.packages[pkg_name] = current_package
            continue

        # Handle standard package lines
        pkg_match = package_pattern.match(stripped)
        if pkg_match:
            pkg_name = pkg_match.group(1).lower()
            operator = pkg_match.group(2)
            version = pkg_match.group(3)
            remainder = pkg_match.group(4).strip()

            # Extract markers (everything after semicolon)
            markers = ""
            if ';' in remainder:
                markers = remainder.split(';', 1)[1].strip()

            # Extract hashes from same line if present
            hashes = []
            hash_matches = hash_pattern.findall(remainder)
            if hash_matches:
                hashes = list(hash_matches)

            current_package = LockedPackage(
                name=pkg_name,
                version=version,
                hashes=hashes,
                markers=markers
            )
            metadata.packages[pkg_name] = current_package
            continue

        # If we get here, the line format is unexpected (but not necessarily invalid)
        # Just continue parsing

    return metadata
