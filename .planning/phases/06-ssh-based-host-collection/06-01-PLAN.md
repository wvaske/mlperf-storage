---
phase: 06-ssh-based-host-collection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mlpstorage/cluster_collector.py
  - tests/unit/test_cluster_collector.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "parse_proc_vmstat returns dict with key-value pairs from /proc/vmstat"
    - "parse_proc_mounts returns list of MountInfo dataclasses"
    - "parse_proc_cgroups returns list of CgroupInfo dataclasses"
    - "collect_local_system_info includes vmstat, mounts, cgroups data"
  artifacts:
    - path: "mlpstorage/cluster_collector.py"
      provides: "New /proc parsers and dataclasses"
      contains: "parse_proc_vmstat"
    - path: "tests/unit/test_cluster_collector.py"
      provides: "Unit tests for new parsers"
      min_lines: 100
  key_links:
    - from: "collect_local_system_info"
      to: "parse_proc_vmstat, parse_proc_mounts, parse_proc_cgroups"
      via: "function calls"
      pattern: "parse_proc_vmstat\\(|parse_proc_mounts\\(|parse_proc_cgroups\\("
---

<objective>
Add parsers for /proc/vmstat, /proc/mounts, and /proc/cgroups to support HOST-02 requirement.

Purpose: Enable collection of vmstat, filesystem, and cgroup information for storage analysis during benchmark execution.

Output: New parser functions, dataclasses, and updated local collection function with unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ssh-based-host-collection/06-RESEARCH.md

@mlpstorage/cluster_collector.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dataclasses and parsers for new /proc files</name>
  <files>mlpstorage/cluster_collector.py</files>
  <action>
Add three new dataclasses and parser functions to cluster_collector.py after existing dataclass and parser sections:

1. Add MountInfo dataclass after HostSystemInfo:
```python
@dataclass
class MountInfo:
    """Mount point information from /proc/mounts."""
    device: str
    mount_point: str
    fs_type: str
    options: str
    dump_freq: int = 0
    pass_num: int = 0

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MountInfo':
        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})
```

2. Add CgroupInfo dataclass:
```python
@dataclass
class CgroupInfo:
    """Cgroup subsystem information from /proc/cgroups."""
    subsys_name: str
    hierarchy: int
    num_cgroups: int
    enabled: bool

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CgroupInfo':
        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})
```

3. Add parse_proc_vmstat function after existing parsers:
```python
def parse_proc_vmstat(content: str) -> Dict[str, int]:
    """Parse /proc/vmstat content into a dictionary.

    Args:
        content: Raw content of /proc/vmstat file.

    Returns:
        Dictionary mapping field names to integer values.
    """
    result = {}
    for line in content.strip().split('\n'):
        parts = line.split()
        if len(parts) == 2:
            try:
                result[parts[0]] = int(parts[1])
            except ValueError:
                pass
    return result
```

4. Add parse_proc_mounts function:
```python
def parse_proc_mounts(content: str) -> List[MountInfo]:
    """Parse /proc/mounts content into a list of MountInfo objects.

    Args:
        content: Raw content of /proc/mounts file.

    Returns:
        List of MountInfo objects, one per mount point.
    """
    mounts = []
    for line in content.strip().split('\n'):
        if not line.strip():
            continue
        parts = line.split()
        if len(parts) >= 4:
            try:
                mount = MountInfo(
                    device=parts[0],
                    mount_point=parts[1],
                    fs_type=parts[2],
                    options=parts[3],
                    dump_freq=int(parts[4]) if len(parts) > 4 else 0,
                    pass_num=int(parts[5]) if len(parts) > 5 else 0,
                )
                mounts.append(mount)
            except (ValueError, IndexError):
                continue
    return mounts
```

5. Add parse_proc_cgroups function:
```python
def parse_proc_cgroups(content: str) -> List[CgroupInfo]:
    """Parse /proc/cgroups content into a list of CgroupInfo objects.

    Args:
        content: Raw content of /proc/cgroups file.

    Returns:
        List of CgroupInfo objects, one per cgroup subsystem.
    """
    cgroups = []
    lines = content.strip().split('\n')
    for line in lines:
        # Skip header line and comments
        if line.startswith('#') or 'subsys_name' in line:
            continue
        parts = line.split()
        if len(parts) >= 4:
            try:
                cgroup = CgroupInfo(
                    subsys_name=parts[0],
                    hierarchy=int(parts[1]),
                    num_cgroups=int(parts[2]),
                    enabled=parts[3] == '1',
                )
                cgroups.append(cgroup)
            except (ValueError, IndexError):
                continue
    return cgroups
```
  </action>
  <verify>
python -c "from mlpstorage.cluster_collector import parse_proc_vmstat, parse_proc_mounts, parse_proc_cgroups, MountInfo, CgroupInfo; print('Imports OK')"
  </verify>
  <done>New dataclasses (MountInfo, CgroupInfo) and parser functions (parse_proc_vmstat, parse_proc_mounts, parse_proc_cgroups) are defined and importable.</done>
</task>

<task type="auto">
  <name>Task 2: Update collect_local_system_info to include new data</name>
  <files>mlpstorage/cluster_collector.py</files>
  <action>
Update the collect_local_system_info() function to also collect /proc/vmstat, /proc/mounts, and /proc/cgroups:

Add after the /etc/os-release collection block (before the "Remove errors dict if empty" section):

```python
    # Collect /proc/vmstat
    try:
        with open('/proc/vmstat', 'r') as f:
            result['vmstat'] = parse_proc_vmstat(f.read())
    except Exception as e:
        result['errors']['vmstat'] = str(e)
        result['vmstat'] = {}

    # Collect /proc/mounts (filesystems)
    try:
        with open('/proc/mounts', 'r') as f:
            mounts = parse_proc_mounts(f.read())
            result['mounts'] = [m.to_dict() for m in mounts]
    except Exception as e:
        result['errors']['mounts'] = str(e)
        result['mounts'] = []

    # Collect /proc/cgroups
    try:
        with open('/proc/cgroups', 'r') as f:
            cgroups = parse_proc_cgroups(f.read())
            result['cgroups'] = [c.to_dict() for c in cgroups]
    except Exception as e:
        result['errors']['cgroups'] = str(e)
        result['cgroups'] = []
```

Also update the docstring for collect_local_system_info to include the new fields:
- vmstat: Dict from /proc/vmstat
- mounts: List[Dict] from /proc/mounts
- cgroups: List[Dict] from /proc/cgroups
  </action>
  <verify>
python -c "from mlpstorage.cluster_collector import collect_local_system_info; info = collect_local_system_info(); print('vmstat keys:', len(info.get('vmstat', {}))); print('mounts:', len(info.get('mounts', []))); print('cgroups:', len(info.get('cgroups', [])))"
  </verify>
  <done>collect_local_system_info() returns vmstat dict, mounts list, and cgroups list from local system.</done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for new parsers</name>
  <files>tests/unit/test_cluster_collector.py</files>
  <action>
Create a new test file tests/unit/test_cluster_collector.py with tests for all new parser functions:

```python
"""Unit tests for cluster_collector module."""

import pytest

from mlpstorage.cluster_collector import (
    parse_proc_vmstat,
    parse_proc_mounts,
    parse_proc_cgroups,
    MountInfo,
    CgroupInfo,
)


class TestParseProcVmstat:
    """Tests for parse_proc_vmstat function."""

    def test_parses_key_value_pairs(self):
        """Test parsing simple key-value pairs."""
        content = """nr_free_pages 12345
nr_zone_inactive_anon 6789
nr_zone_active_anon 1111"""
        result = parse_proc_vmstat(content)
        assert result['nr_free_pages'] == 12345
        assert result['nr_zone_inactive_anon'] == 6789
        assert result['nr_zone_active_anon'] == 1111

    def test_handles_empty_content(self):
        """Test parsing empty content."""
        result = parse_proc_vmstat("")
        assert result == {}

    def test_skips_invalid_lines(self):
        """Test that invalid lines are skipped."""
        content = """nr_free_pages 12345
invalid_line_no_value
nr_active 100"""
        result = parse_proc_vmstat(content)
        assert 'nr_free_pages' in result
        assert 'nr_active' in result
        assert 'invalid_line_no_value' not in result

    def test_skips_non_integer_values(self):
        """Test that non-integer values are skipped."""
        content = """nr_free_pages 12345
some_metric not_a_number
nr_active 100"""
        result = parse_proc_vmstat(content)
        assert result['nr_free_pages'] == 12345
        assert 'some_metric' not in result


class TestParseProcMounts:
    """Tests for parse_proc_mounts function."""

    def test_parses_mount_entries(self):
        """Test parsing standard mount entries."""
        content = """/dev/sda1 / ext4 rw,relatime 0 1
tmpfs /run tmpfs rw,nosuid,nodev 0 0"""
        result = parse_proc_mounts(content)
        assert len(result) == 2
        assert result[0].device == '/dev/sda1'
        assert result[0].mount_point == '/'
        assert result[0].fs_type == 'ext4'
        assert result[0].options == 'rw,relatime'
        assert result[0].dump_freq == 0
        assert result[0].pass_num == 1

    def test_handles_minimal_fields(self):
        """Test parsing with only required 4 fields."""
        content = "/dev/sda1 /mnt ext4 defaults"
        result = parse_proc_mounts(content)
        assert len(result) == 1
        assert result[0].device == '/dev/sda1'
        assert result[0].dump_freq == 0
        assert result[0].pass_num == 0

    def test_handles_empty_content(self):
        """Test parsing empty content."""
        result = parse_proc_mounts("")
        assert result == []

    def test_mount_info_to_dict(self):
        """Test MountInfo.to_dict method."""
        mount = MountInfo(
            device='/dev/sda1',
            mount_point='/',
            fs_type='ext4',
            options='rw'
        )
        d = mount.to_dict()
        assert d['device'] == '/dev/sda1'
        assert d['mount_point'] == '/'


class TestParseProcCgroups:
    """Tests for parse_proc_cgroups function."""

    def test_parses_cgroup_entries(self):
        """Test parsing cgroup entries."""
        content = """#subsys_name	hierarchy	num_cgroups	enabled
cpu	0	1	1
memory	0	1	1
pids	0	1	0"""
        result = parse_proc_cgroups(content)
        assert len(result) == 3
        assert result[0].subsys_name == 'cpu'
        assert result[0].hierarchy == 0
        assert result[0].num_cgroups == 1
        assert result[0].enabled is True
        assert result[2].enabled is False

    def test_skips_header_line(self):
        """Test that header line is skipped."""
        content = """#subsys_name	hierarchy	num_cgroups	enabled
cpu	0	1	1"""
        result = parse_proc_cgroups(content)
        assert len(result) == 1
        assert result[0].subsys_name == 'cpu'

    def test_handles_empty_content(self):
        """Test parsing empty content."""
        result = parse_proc_cgroups("")
        assert result == []

    def test_cgroup_info_to_dict(self):
        """Test CgroupInfo.to_dict method."""
        cgroup = CgroupInfo(
            subsys_name='cpu',
            hierarchy=0,
            num_cgroups=1,
            enabled=True
        )
        d = cgroup.to_dict()
        assert d['subsys_name'] == 'cpu'
        assert d['enabled'] is True
```
  </action>
  <verify>pytest tests/unit/test_cluster_collector.py -v</verify>
  <done>All unit tests for new parsers pass (TestParseProcVmstat, TestParseProcMounts, TestParseProcCgroups).</done>
</task>

</tasks>

<verification>
1. All new parsers are importable: `python -c "from mlpstorage.cluster_collector import parse_proc_vmstat, parse_proc_mounts, parse_proc_cgroups"`
2. collect_local_system_info includes new data: Run and verify vmstat/mounts/cgroups in output
3. Unit tests pass: `pytest tests/unit/test_cluster_collector.py -v`
</verification>

<success_criteria>
1. parse_proc_vmstat parses /proc/vmstat key-value pairs into dict
2. parse_proc_mounts parses /proc/mounts into list of MountInfo
3. parse_proc_cgroups parses /proc/cgroups into list of CgroupInfo
4. collect_local_system_info includes vmstat, mounts, cgroups
5. All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-ssh-based-host-collection/06-01-SUMMARY.md`
</output>
