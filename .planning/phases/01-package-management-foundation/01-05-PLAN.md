---
phase: 01-package-management-foundation
plan: 05
type: execute
wave: 3
depends_on: ["01-03", "01-04"]
files_modified:
  - mlpstorage/cli/lockfile_args.py
  - mlpstorage/cli/__init__.py
  - mlpstorage/cli_parser.py
  - mlpstorage/main.py
  - mlpstorage/cli/common_args.py
autonomous: true

must_haves:
  truths:
    - "User can run 'mlpstorage lockfile generate' to create a lockfile"
    - "User can run 'mlpstorage lockfile verify' to validate package versions"
    - "Benchmark execution validates lockfile when --verify-lockfile flag is passed"
    - "Clear error message shown when lockfile validation fails before benchmark"
  artifacts:
    - path: "mlpstorage/cli/lockfile_args.py"
      provides: "CLI argument builder for lockfile subcommand"
      exports: ["add_lockfile_arguments"]
    - path: "mlpstorage/cli_parser.py"
      provides: "Updated parser with lockfile subcommand"
      contains: "lockfile_parsers"
    - path: "mlpstorage/main.py"
      provides: "Lockfile command handler and benchmark integration"
      contains: "handle_lockfile_command"
  key_links:
    - from: "mlpstorage/main.py"
      to: "mlpstorage/lockfile/generator.py"
      via: "generate_lockfile call"
      pattern: "generate_lockfile"
    - from: "mlpstorage/main.py"
      to: "mlpstorage/lockfile/validator.py"
      via: "validate_lockfile call"
      pattern: "validate_lockfile"
---

<objective>
Integrate lockfile generation and validation into the mlpstorage CLI and benchmark execution.

Purpose: Enable users to manage lockfiles through the CLI (`mlpstorage lockfile generate/verify`) and optionally validate package versions before benchmark execution (`--verify-lockfile`). This completes PKG-01 and PKG-03.

Output: New `mlpstorage lockfile` CLI subcommand with generate/verify commands, and `--verify-lockfile` flag for benchmark commands.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-package-management-foundation/01-RESEARCH.md

# Module structure from prior plans (01-03, 01-04)
@mlpstorage/lockfile/__init__.py

# Existing CLI patterns to follow
@mlpstorage/cli/__init__.py
@mlpstorage/cli/utility_args.py
@mlpstorage/cli_parser.py
@mlpstorage/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lockfile CLI argument builder</name>
  <files>mlpstorage/cli/lockfile_args.py</files>
  <action>
Create `mlpstorage/cli/lockfile_args.py` following the pattern from `utility_args.py`:

```python
"""
CLI argument builder for lockfile management commands.

Provides arguments for:
- mlpstorage lockfile generate: Create lockfile from pyproject.toml
- mlpstorage lockfile verify: Validate installed packages against lockfile
"""

from mlpstorage.cli.common_args import add_universal_arguments


def add_lockfile_arguments(parser):
    """Add lockfile subcommands to the parser.

    Args:
        parser: The lockfile subparser from argparse.
    """
    subparsers = parser.add_subparsers(dest="lockfile_command", required=True)

    # Generate subcommand
    generate_parser = subparsers.add_parser(
        "generate",
        help="Generate lockfile from pyproject.toml",
        description="Generate a requirements.txt lockfile with pinned versions using uv pip compile.",
    )
    generate_parser.add_argument(
        "-o", "--output",
        default="requirements.txt",
        help="Output path for lockfile (default: requirements.txt)",
    )
    generate_parser.add_argument(
        "--extra",
        action="append",
        dest="extras",
        help="Include optional dependency group (can be repeated, e.g., --extra test --extra full)",
    )
    generate_parser.add_argument(
        "--hashes",
        action="store_true",
        help="Include SHA256 hashes in lockfile (slower but more secure)",
    )
    generate_parser.add_argument(
        "--python-version",
        help="Target Python version (e.g., 3.10)",
    )
    generate_parser.add_argument(
        "--pyproject",
        default="pyproject.toml",
        help="Path to pyproject.toml (default: pyproject.toml)",
    )
    generate_parser.add_argument(
        "--all",
        action="store_true",
        dest="generate_all",
        help="Generate both requirements.txt and requirements-full.txt",
    )
    add_universal_arguments(generate_parser)

    # Verify subcommand
    verify_parser = subparsers.add_parser(
        "verify",
        help="Verify installed packages match lockfile",
        description="Check that installed package versions match the lockfile.",
    )
    verify_parser.add_argument(
        "-l", "--lockfile",
        default="requirements.txt",
        help="Path to lockfile (default: requirements.txt)",
    )
    verify_parser.add_argument(
        "--skip",
        action="append",
        dest="skip_packages",
        help="Package names to skip validation (can be repeated)",
    )
    verify_parser.add_argument(
        "--allow-missing",
        action="store_true",
        help="Don't fail if packages are missing (only check installed versions)",
    )
    verify_parser.add_argument(
        "--strict",
        action="store_true",
        help="Fail on any difference (default: fail only on version mismatch)",
    )
    add_universal_arguments(verify_parser)

    return parser
```
  </action>
  <verify>
Run: `python -c "from mlpstorage.cli.lockfile_args import add_lockfile_arguments; print('Import OK')"`
  </verify>
  <done>
`lockfile_args.py` exists with `add_lockfile_arguments()` function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CLI module exports and parser</name>
  <files>mlpstorage/cli/__init__.py, mlpstorage/cli_parser.py</files>
  <action>
1. Update `mlpstorage/cli/__init__.py` to export lockfile arguments:

Add import:
```python
from mlpstorage.cli.lockfile_args import add_lockfile_arguments
```

Add to `__all__`:
```python
'add_lockfile_arguments',
```

2. Update `mlpstorage/cli_parser.py` to add lockfile subparser:

Add import at top:
```python
from mlpstorage.cli import add_lockfile_arguments
```

After the existing parser definitions (around line 63-67, after history_parsers), add:
```python
lockfile_parsers = sub_programs.add_parser(
    "lockfile",
    description="Manage package lockfiles for reproducible environments",
    help="Generate and verify package lockfiles"
)
```

Add to sub_programs_map dict:
```python
'lockfile': lockfile_parsers,
```

Add argument builder call (around line 82):
```python
add_lockfile_arguments(lockfile_parsers)
```
  </action>
  <verify>
Run: `python -m mlpstorage.cli_parser 2>&1 | head -20` to verify parser loads without error.
Run: `mlpstorage lockfile --help` to verify subcommand is available.
  </verify>
  <done>
CLI parser includes lockfile subcommand with generate and verify subcommands.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add lockfile command handler to main.py</name>
  <files>mlpstorage/main.py</files>
  <action>
Update `mlpstorage/main.py` to handle lockfile commands:

1. Add import at top (around line 30):
```python
from mlpstorage.lockfile import (
    generate_lockfile,
    generate_lockfiles_for_project,
    validate_lockfile,
    format_validation_report,
    LockfileGenerationError,
    GenerationOptions,
)
```

2. Add handler function (before `_main_impl()`):
```python
def handle_lockfile_command(args) -> int:
    """Handle lockfile generate/verify commands.

    Args:
        args: Parsed command line arguments.

    Returns:
        Exit code (0 for success).
    """
    if args.lockfile_command == "generate":
        try:
            if args.generate_all:
                # Generate both base and full lockfiles
                logger.info("Generating lockfiles...")
                results = generate_lockfiles_for_project(args.pyproject)
                for name, path in results.items():
                    logger.status(f"Generated {name} lockfile: {path}")
                return EXIT_CODE.SUCCESS
            else:
                # Generate single lockfile
                options = GenerationOptions(
                    output_path=args.output,
                    extras=args.extras,
                    generate_hashes=args.hashes,
                    python_version=args.python_version or "",
                )
                logger.info(f"Generating lockfile: {args.output}")
                _, path = generate_lockfile(args.pyproject, options)
                logger.status(f"Generated lockfile: {path}")
                return EXIT_CODE.SUCCESS
        except LockfileGenerationError as e:
            logger.error(f"Lockfile generation failed: {e}")
            if e.stderr:
                logger.debug(f"stderr: {e.stderr}")
            return EXIT_CODE.FAILURE
        except FileNotFoundError as e:
            logger.error(str(e))
            return EXIT_CODE.FAILURE

    elif args.lockfile_command == "verify":
        try:
            skip = set(args.skip_packages) if args.skip_packages else None
            result = validate_lockfile(
                args.lockfile,
                skip_packages=skip,
                fail_on_missing=not args.allow_missing,
            )

            # Print report
            report = format_validation_report(result)
            if result.valid:
                logger.status(report)
                return EXIT_CODE.SUCCESS
            else:
                logger.error(report)
                return EXIT_CODE.FAILURE
        except FileNotFoundError:
            logger.error(f"Lockfile not found: {args.lockfile}")
            logger.info("Generate a lockfile with: mlpstorage lockfile generate")
            return EXIT_CODE.FAILURE

    return EXIT_CODE.FAILURE
```

3. Add lockfile handling in `_main_impl()` (after history handling, around line 163):
```python
if args.program == "lockfile":
    return handle_lockfile_command(args)
```
  </action>
  <verify>
Run: `mlpstorage lockfile generate --help` to verify generate command works.
Run: `mlpstorage lockfile verify --help` to verify verify command works.
  </verify>
  <done>
`mlpstorage lockfile generate` and `mlpstorage lockfile verify` commands are functional.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add --verify-lockfile flag to benchmark commands</name>
  <files>mlpstorage/cli/common_args.py, mlpstorage/benchmarks/base.py, mlpstorage/main.py</files>
  <action>
Implement benchmark integration so that running benchmarks with `--verify-lockfile` validates packages before execution.

1. Add `--verify-lockfile` argument to common arguments in `mlpstorage/cli/common_args.py`:

In `add_universal_arguments()` function, add:
```python
parser.add_argument(
    "--verify-lockfile",
    type=str,
    metavar="PATH",
    help="Validate installed packages against lockfile before benchmark execution",
)
```

2. Add validation call in `mlpstorage/main.py` before benchmark execution.

In `run_benchmark()` function (around line 85), after argument parsing but before benchmark instantiation, add:
```python
# Validate lockfile if requested
if hasattr(args, 'verify_lockfile') and args.verify_lockfile:
    from mlpstorage.lockfile import validate_lockfile, format_validation_report
    logger.info(f"Validating packages against lockfile: {args.verify_lockfile}")
    try:
        result = validate_lockfile(args.verify_lockfile, fail_on_missing=False)
        if not result.valid:
            report = format_validation_report(result)
            logger.error("Package version mismatch detected:")
            logger.error(report)
            logger.error("")
            logger.error("To fix, run one of:")
            logger.error(f"  pip install -r {args.verify_lockfile}")
            logger.error("  uv pip sync " + args.verify_lockfile)
            logger.error("")
            logger.error("Or run without lockfile validation:")
            logger.error(f"  {' '.join(sys.argv).replace('--verify-lockfile ' + args.verify_lockfile, '').strip()}")
            return EXIT_CODE.FAILURE
        logger.status(f"Package validation passed ({result.checked_count} packages verified)")
    except FileNotFoundError:
        logger.error(f"Lockfile not found: {args.verify_lockfile}")
        logger.error("Generate a lockfile with: mlpstorage lockfile generate")
        return EXIT_CODE.FAILURE
```

3. Update `run_benchmark()` to import sys at top if not already imported.
  </action>
  <verify>
Run: `mlpstorage training run --help | grep verify-lockfile` to verify flag is present.
Create a test lockfile with wrong version and verify benchmark fails:
```bash
echo "numpy==0.0.1" > /tmp/bad-lockfile.txt
mlpstorage training run --model unet3d --verify-lockfile /tmp/bad-lockfile.txt 2>&1 | grep -i "mismatch\|version"
```
  </verify>
  <done>
Benchmark commands support `--verify-lockfile` flag that validates packages before execution and fails with clear message on mismatch.
  </done>
</task>

</tasks>

<verification>
- [ ] `mlpstorage lockfile --help` shows generate and verify subcommands
- [ ] `mlpstorage lockfile generate --help` shows all options (output, extra, hashes, etc.)
- [ ] `mlpstorage lockfile verify --help` shows all options (lockfile, skip, allow-missing)
- [ ] `mlpstorage lockfile generate -o /tmp/test-lock.txt` creates lockfile (requires uv)
- [ ] `mlpstorage lockfile verify -l /tmp/test-lock.txt` validates packages
- [ ] Errors include helpful suggestions for resolution
- [ ] `mlpstorage training run --verify-lockfile` validates packages before benchmark
- [ ] Benchmark fails with clear error message when package versions don't match lockfile
</verification>

<success_criteria>
1. `mlpstorage lockfile generate` creates requirements.txt from pyproject.toml
2. `mlpstorage lockfile verify` validates installed packages against lockfile
3. `mlpstorage lockfile generate --all` creates both base and full lockfiles
4. Error messages are clear and actionable
5. CLI follows existing mlpstorage patterns
6. Benchmark execution fails with clear message when package versions differ from lockfile (Phase SC4)
7. `--verify-lockfile` flag available on all benchmark commands
</success_criteria>

<output>
After completion, create `.planning/phases/01-package-management-foundation/01-05-SUMMARY.md`
</output>
