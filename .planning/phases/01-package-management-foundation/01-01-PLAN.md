---
phase: 01-package-management-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mlpstorage/lockfile/__init__.py
  - mlpstorage/lockfile/models.py
autonomous: true

must_haves:
  truths:
    - "Lockfile entries can be parsed from requirements.txt format"
    - "Validation results capture package name, expected version, actual version, and status"
    - "Module can be imported without errors"
  artifacts:
    - path: "mlpstorage/lockfile/__init__.py"
      provides: "Package initialization and public exports"
      min_lines: 10
    - path: "mlpstorage/lockfile/models.py"
      provides: "Data classes for lockfile entries and validation results"
      exports: ["LockedPackage", "ValidationResult", "LockfileMetadata"]
  key_links:
    - from: "mlpstorage/lockfile/__init__.py"
      to: "mlpstorage/lockfile/models.py"
      via: "import and re-export"
      pattern: "from.*models.*import"
---

<objective>
Create the lockfile module structure with data models for lockfile entries and validation results.

Purpose: Establish the foundational data structures that the generator and validator will use. This enables parallel development of generation and validation functionality.

Output: New `mlpstorage/lockfile/` module with data classes for `LockedPackage`, `ValidationResult`, and `LockfileMetadata`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-package-management-foundation/01-RESEARCH.md

# Existing code patterns to follow
@mlpstorage/rules/models.py
@mlpstorage/errors.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lockfile module structure</name>
  <files>mlpstorage/lockfile/__init__.py, mlpstorage/lockfile/models.py</files>
  <action>
Create the `mlpstorage/lockfile/` directory and initialize the module:

1. Create `mlpstorage/lockfile/__init__.py`:
   - Add module docstring explaining lockfile operations for reproducible environments
   - Import and re-export public classes from models.py
   - Define `__all__` with public exports

2. Create `mlpstorage/lockfile/models.py` with these data classes:

```python
@dataclass
class LockedPackage:
    """A package entry from a lockfile with pinned version."""
    name: str           # Distribution name (e.g., "requests")
    version: str        # Pinned version (e.g., "2.31.0")
    hashes: list[str] = field(default_factory=list)  # SHA256 hashes
    markers: str = ""   # Environment markers (e.g., "; python_version >= '3.10'")
    is_editable: bool = False  # Whether package is installed in editable mode
    source_url: str = ""  # For VCS/URL dependencies (e.g., git+https://...)

@dataclass
class ValidationResult:
    """Result of validating a single package against lockfile."""
    package: str        # Package name
    expected: str       # Version from lockfile
    actual: str | None  # Installed version (None if not installed)
    valid: bool         # Whether versions match
    message: str        # Human-readable status message

@dataclass
class LockfileMetadata:
    """Metadata about a lockfile."""
    path: str           # Path to lockfile
    generated_by: str = ""  # Tool that generated it (e.g., "uv pip compile")
    generation_date: str = ""  # ISO date string
    python_version: str = ""  # Python version constraint
    platform: str = ""  # Platform (e.g., "linux", "universal")
    packages: dict[str, LockedPackage] = field(default_factory=dict)
```

Follow the pattern from `mlpstorage/rules/models.py` for dataclass style. Use `from dataclasses import dataclass, field` and type hints throughout.
  </action>
  <verify>
Run: `python -c "from mlpstorage.lockfile import LockedPackage, ValidationResult, LockfileMetadata; print('Import OK')"`
  </verify>
  <done>
Module imports successfully. All three data classes are accessible from `mlpstorage.lockfile`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add lockfile parsing utility</name>
  <files>mlpstorage/lockfile/models.py</files>
  <action>
Add a `parse_lockfile()` function to models.py that parses requirements.txt format:

```python
def parse_lockfile(lockfile_path: str) -> LockfileMetadata:
    """Parse a pip-compile/uv generated requirements.txt lockfile.

    Handles:
    - Package==version lines
    - --hash=sha256:xxx lines
    - # comments (including via: lines for source tracking)
    - Environment markers (package==1.0; python_version >= '3.10')
    - VCS/URL dependencies (package @ git+https://...)

    Args:
        lockfile_path: Path to the requirements.txt lockfile

    Returns:
        LockfileMetadata with parsed packages

    Raises:
        FileNotFoundError: If lockfile doesn't exist
        ValueError: If lockfile format is invalid
    """
```

Implementation notes:
- Use regex to match `^([a-zA-Z0-9_-]+)==([^\s;]+)` for package lines
- Collect `--hash=sha256:xxx` lines and associate with previous package
- Extract environment markers after `;`
- Handle VCS deps: `package @ git+https://...`
- Parse header comments for metadata (generated by, date, etc.)
- Normalize package names to lowercase for dict keys
- Return LockfileMetadata with packages dict

Add to `__all__` in `__init__.py`.
  </action>
  <verify>
Create a test requirements.txt and verify parsing:
```bash
echo -e "# Generated by uv pip compile\nrequests==2.31.0 \\\n    --hash=sha256:abc123\npyaml>=6.0" > /tmp/test_lockfile.txt
python -c "
from mlpstorage.lockfile import parse_lockfile
meta = parse_lockfile('/tmp/test_lockfile.txt')
print(f'Packages: {list(meta.packages.keys())}')
print(f'requests version: {meta.packages[\"requests\"].version}')
"
```
  </verify>
  <done>
`parse_lockfile()` correctly parses requirements.txt format, extracting package names, versions, and hashes.
  </done>
</task>

</tasks>

<verification>
- [ ] `mlpstorage/lockfile/` directory exists
- [ ] `from mlpstorage.lockfile import LockedPackage, ValidationResult, LockfileMetadata, parse_lockfile` works
- [ ] Data classes have proper type hints and docstrings
- [ ] `parse_lockfile()` handles standard requirements.txt format
- [ ] No import errors when running `python -c "import mlpstorage.lockfile"`
</verification>

<success_criteria>
1. New `mlpstorage/lockfile/` module exists with `__init__.py` and `models.py`
2. Three data classes are defined: `LockedPackage`, `ValidationResult`, `LockfileMetadata`
3. `parse_lockfile()` function correctly parses requirements.txt format
4. Module follows existing codebase patterns (dataclasses, type hints, docstrings)
</success_criteria>

<output>
After completion, create `.planning/phases/01-package-management-foundation/01-01-SUMMARY.md`
</output>
