---
phase: 01-package-management-foundation
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - mlpstorage/lockfile/validator.py
  - mlpstorage/lockfile/__init__.py
autonomous: true

must_haves:
  truths:
    - "User can validate installed packages against a lockfile"
    - "Version mismatches are clearly reported with expected vs actual"
    - "Missing packages are detected and reported"
    - "Validation returns structured results for programmatic use"
  artifacts:
    - path: "mlpstorage/lockfile/validator.py"
      provides: "Runtime version validation against lockfile"
      exports: ["validate_lockfile", "LockfileValidationResult"]
  key_links:
    - from: "mlpstorage/lockfile/validator.py"
      to: "importlib.metadata"
      via: "version() function call"
      pattern: "importlib\\.metadata.*version"
    - from: "mlpstorage/lockfile/validator.py"
      to: "mlpstorage/lockfile/models.py"
      via: "parse_lockfile and ValidationResult"
      pattern: "from.*models.*import"
---

<objective>
Implement runtime version validation that compares installed package versions against a lockfile.

Purpose: Enable detection of version mismatches before benchmark execution to ensure reproducibility. This supports PKG-03 (validate package versions match lockfile before benchmark execution).

Output: `mlpstorage/lockfile/validator.py` with `validate_lockfile()` function that returns structured validation results.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-package-management-foundation/01-RESEARCH.md

# Module structure from Plan 01
@mlpstorage/lockfile/models.py
@mlpstorage/lockfile/__init__.py

# Existing error patterns
@mlpstorage/errors.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lockfile validator module</name>
  <files>mlpstorage/lockfile/validator.py</files>
  <action>
Create `mlpstorage/lockfile/validator.py` with version validation functionality:

```python
"""
Runtime package version validation against lockfiles.

Uses importlib.metadata to check installed versions match lockfile expectations.
"""

from dataclasses import dataclass, field
from importlib.metadata import version, PackageNotFoundError
from typing import Optional

from mlpstorage.lockfile.models import (
    parse_lockfile,
    LockedPackage,
    ValidationResult,
    LockfileMetadata,
)


@dataclass
class LockfileValidationResult:
    """Overall result of lockfile validation."""
    valid: bool                              # True if all packages match
    lockfile_path: str                       # Path to lockfile used
    total_packages: int                      # Total packages in lockfile
    matched: int                             # Packages with matching versions
    mismatched: int                          # Packages with version differences
    missing: int                             # Packages not installed
    skipped: int                             # Packages skipped (VCS deps, etc.)
    results: list[ValidationResult] = field(default_factory=list)
    skip_patterns: list[str] = field(default_factory=list)  # Patterns that were skipped

    @property
    def summary(self) -> str:
        """Human-readable summary of validation results."""
        if self.valid:
            return f"All {self.matched} packages match lockfile"
        issues = []
        if self.mismatched:
            issues.append(f"{self.mismatched} version mismatch(es)")
        if self.missing:
            issues.append(f"{self.missing} missing package(s)")
        return f"Validation failed: {', '.join(issues)}"


# Packages that should be skipped during validation
# mpi4py must match system MPI, so version validation doesn't make sense
DEFAULT_SKIP_PACKAGES = frozenset({"mpi4py"})


def validate_package(
    name: str,
    expected_version: str,
    is_vcs: bool = False,
) -> ValidationResult:
    """Validate a single package version.

    Args:
        name: Distribution name (e.g., "requests")
        expected_version: Version from lockfile
        is_vcs: True if this is a VCS/URL dependency (skip version check)

    Returns:
        ValidationResult with status and message.
    """
    if is_vcs:
        # VCS dependencies don't have pinned versions we can check
        return ValidationResult(
            package=name,
            expected=expected_version,
            actual="(VCS dependency)",
            valid=True,
            message=f"{name}: VCS dependency, version not validated",
        )

    try:
        installed = version(name)
        if installed == expected_version:
            return ValidationResult(
                package=name,
                expected=expected_version,
                actual=installed,
                valid=True,
                message=f"{name}: {installed} matches lockfile",
            )
        else:
            return ValidationResult(
                package=name,
                expected=expected_version,
                actual=installed,
                valid=False,
                message=f"{name}: expected {expected_version}, found {installed}",
            )
    except PackageNotFoundError:
        return ValidationResult(
            package=name,
            expected=expected_version,
            actual=None,
            valid=False,
            message=f"{name}: not installed (expected {expected_version})",
        )


def validate_lockfile(
    lockfile_path: str = "requirements.txt",
    skip_packages: Optional[set[str]] = None,
    fail_on_missing: bool = True,
) -> LockfileValidationResult:
    """Validate installed packages against a lockfile.

    Checks that all packages in the lockfile are installed with matching versions.
    VCS/URL dependencies (git+https://) are skipped since they don't have
    version numbers that can be compared.

    Args:
        lockfile_path: Path to requirements.txt lockfile
        skip_packages: Package names to skip (default: {"mpi4py"})
        fail_on_missing: If True, missing packages fail validation

    Returns:
        LockfileValidationResult with detailed per-package results.

    Raises:
        FileNotFoundError: If lockfile doesn't exist
    """
    if skip_packages is None:
        skip_packages = set(DEFAULT_SKIP_PACKAGES)

    # Parse the lockfile
    metadata = parse_lockfile(lockfile_path)

    results = []
    matched = 0
    mismatched = 0
    missing = 0
    skipped = 0
    skip_patterns_used = []

    for name, locked in metadata.packages.items():
        # Skip explicitly excluded packages
        if name.lower() in {p.lower() for p in skip_packages}:
            skipped += 1
            skip_patterns_used.append(name)
            continue

        # Check if VCS dependency
        is_vcs = bool(locked.source_url) and locked.source_url.startswith(("git+", "hg+", "svn+"))

        result = validate_package(name, locked.version, is_vcs=is_vcs)
        results.append(result)

        if is_vcs:
            skipped += 1
        elif result.valid:
            matched += 1
        elif result.actual is None:
            missing += 1
        else:
            mismatched += 1

    # Determine overall validity
    valid = mismatched == 0 and (not fail_on_missing or missing == 0)

    return LockfileValidationResult(
        valid=valid,
        lockfile_path=lockfile_path,
        total_packages=len(metadata.packages),
        matched=matched,
        mismatched=mismatched,
        missing=missing,
        skipped=skipped,
        results=results,
        skip_patterns=skip_patterns_used,
    )


def format_validation_report(result: LockfileValidationResult) -> str:
    """Format validation result as a human-readable report.

    Args:
        result: LockfileValidationResult from validate_lockfile()

    Returns:
        Multi-line string with validation report.
    """
    lines = [
        f"Lockfile Validation Report",
        f"==========================",
        f"Lockfile: {result.lockfile_path}",
        f"Status: {'PASSED' if result.valid else 'FAILED'}",
        f"",
        f"Summary: {result.total_packages} packages",
        f"  Matched:    {result.matched}",
        f"  Mismatched: {result.mismatched}",
        f"  Missing:    {result.missing}",
        f"  Skipped:    {result.skipped}",
    ]

    # Show issues if any
    issues = [r for r in result.results if not r.valid]
    if issues:
        lines.append("")
        lines.append("Issues:")
        for issue in issues:
            lines.append(f"  - {issue.message}")

    return "\n".join(lines)
```
  </action>
  <verify>
Run:
```bash
python -c "
from mlpstorage.lockfile.validator import validate_package
result = validate_package('packaging', '21.0')
print(f'Package: {result.package}, Valid: {result.valid}, Message: {result.message}')
"
```
  </verify>
  <done>
`validator.py` exists with `validate_lockfile()`, `validate_package()`, and `format_validation_report()`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update lockfile module exports</name>
  <files>mlpstorage/lockfile/__init__.py</files>
  <action>
Update `mlpstorage/lockfile/__init__.py` to export the validator functions:

Add imports:
```python
from mlpstorage.lockfile.validator import (
    validate_lockfile,
    validate_package,
    format_validation_report,
    LockfileValidationResult,
    DEFAULT_SKIP_PACKAGES,
)
```

Update `__all__` to include:
```python
__all__ = [
    # Models
    "LockedPackage",
    "ValidationResult",
    "LockfileMetadata",
    "parse_lockfile",
    # Generator
    "generate_lockfile",
    "generate_lockfiles_for_project",
    "check_uv_available",
    "LockfileGenerationError",
    "GenerationOptions",
    # Validator
    "validate_lockfile",
    "validate_package",
    "format_validation_report",
    "LockfileValidationResult",
    "DEFAULT_SKIP_PACKAGES",
]
```
  </action>
  <verify>
Run: `python -c "from mlpstorage.lockfile import validate_lockfile, LockfileValidationResult; print('Exports OK')"`
  </verify>
  <done>
All validator exports are accessible from `mlpstorage.lockfile`.
  </done>
</task>

</tasks>

<verification>
- [ ] `mlpstorage/lockfile/validator.py` exists
- [ ] `from mlpstorage.lockfile import validate_lockfile` works
- [ ] `validate_package()` correctly detects version matches and mismatches
- [ ] `validate_lockfile()` parses lockfile and validates all packages
- [ ] VCS dependencies are skipped with appropriate message
- [ ] mpi4py is in DEFAULT_SKIP_PACKAGES
- [ ] `format_validation_report()` produces readable output
</verification>

<success_criteria>
1. `validate_lockfile()` returns structured `LockfileValidationResult`
2. Version mismatches are clearly identified with expected vs actual
3. Missing packages are detected when `fail_on_missing=True`
4. VCS/URL dependencies are skipped gracefully
5. mpi4py is excluded from validation by default (system MPI dependency)
</success_criteria>

<output>
After completion, create `.planning/phases/01-package-management-foundation/01-04-SUMMARY.md`
</output>
